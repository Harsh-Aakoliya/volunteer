// api/auth.ts
import axios from "axios";
import { Alert, Platform } from "react-native";
import { API_URL } from "../constants/api";
import { AuthStorage } from "@/utils/authStorage";
import { router } from "expo-router";
import * as Notifications from "expo-notifications";
import Constants from "expo-constants";
import { setUserOnlineGlobal, setUserOfflineGlobal, resetOnlineStatusState } from '@/hooks/useOnlineStatus';
import socketService from '@/utils/socketService';

// Helper function to check internet connectivity (using same approach as useNetworkStatus hook)
const checkInternetConnectivity = async (): Promise<boolean> => {
  try {
    // Try to ping a fast, reliable endpoint (same as your useNetworkStatus hook)
    const response = await fetch("https://www.google.com", { method: "HEAD" });
    return response.ok;
  } catch (error) {
    console.error("Internet connectivity check failed:", error);
    return false;
  }
};

export const checkMobileExists = async (mobileNumber: string): Promise<{ exists: boolean; message?: string }> => {
  try {
    const response = await fetch(`${API_URL}/api/auth/check-mobile`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ mobileNumber }),
    });

    return await response.json();
  } catch (error) {
    console.error("Check mobile error:", error);
    throw new Error("Failed to verify mobile number");
  }
};
const generateAndStoreNotificationToken = async (userId: string) => {
  try {
    // Check internet connectivity first
    const isConnected = await checkInternetConnectivity();
    if (!isConnected) {
      console.log('No internet connection available for notification token generation');
      return;
    }

    // Request notification permissions
    const { status } = await Notifications.requestPermissionsAsync();
    if (status !== 'granted') {
      console.log('Notification permission not granted');
      return;
    }

    // FCM token
    const { data: rawFcm } = await Notifications.getDevicePushTokenAsync();
    console.log("FCM token:", rawFcm);

    // Get Expo push token
    // const expoPushToken = (
    //   await Notifications.getExpoPushTokenAsync({
    //     projectId: Constants?.expoConfig?.extra?.eas?.projectId,
    //   })
    // ).data;

    // if (!expoPushToken) {
    //   console.log('Failed to get Expo push token');
    //   return;
    // }

    // console.log('Generated Expo push token:', expoPushToken);

    // Store token in backend
    const token = await AuthStorage.getToken();
    if (token) {
      const response = await axios.post(`${API_URL}/api/notifications/store-token`, {
        userId,
        token: rawFcm,
        tokenType: 'fcm',
        deviceInfo: {
          platform: Constants.platform?.ios ? 'ios' : 'android',
          deviceId: Constants.deviceId,
          appVersion: Constants.expoConfig?.version
        }
      }, {
        headers: { Authorization: `Bearer ${token}` }
      });

      console.log('Token stored successfully:', response.data);
    }
  } catch (error) {
    console.error('Error generating/storing notification token:', error);
  }
};

const removeNotificationToken = async (userId: string) => {
  try {
    const token = await AuthStorage.getToken();
    if (token) {
      await axios.post(`${API_URL}/api/notifications/delete-token`, {
        userId,
        tokenType: 'fcm'
      }, {
        headers: { Authorization: `Bearer ${token}` }
      });
      console.log('Notification token removed successfully');
    }
  } catch (error) {
    console.error('Error removing notification token:', error);
  }
};

export const login = async (mobileNumber: string, password: string) => {
  try {
    const response = await axios.post(`${API_URL}/api/auth/login`, {
      mobileNumber,
      password
    });
    console.log("response in login", response.data);
    return response.data;
  } catch (error: any) {
    Alert.alert("Error", error.response.data.message);
    return error.response.data;
  }
};

export const register = async (mobileNumber: string, userId: string, fullName: string) => {
  try {
    const response = await axios.post(`${API_URL}/api/auth/register`, {
      mobileNumber,
      userId,
      fullName,
    });
    return response.data;
  } catch (error: any) {
    console.error("Registration error", error);
  }
};

export const logout = async () => {
  try {
    // Get current user data before clearing storage
    const userData = await AuthStorage.getUser();
    
    if (userData?.userId) {
      // Set user offline before logging out
      try {
        await setUserOfflineGlobal(userData.userId);
        
        // Wait a bit for the offline status to be broadcast
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Disconnect socket
        socketService.disconnect();
      } catch (error) {
        console.error('Error setting user offline during logout:', error);
      }
      
      // Remove notification token from backend
      await removeNotificationToken(userData.userId);
    }

    // Reset online status state
    resetOnlineStatusState();

    // Clear local storage
    await AuthStorage.clear();
    
    // Redirect to login page
    router.replace("/login");
    
    console.log('Logout successful');
  } catch (error) {
    console.error('Error during logout:', error);
    // Clear storage anyway in case of error
    await AuthStorage.clear();
    resetOnlineStatusState();
    router.replace("/login");
  }
};

// Function to handle token generation when app starts and user is already logged in
export const handleAppStartNotificationToken = async () => {
  try {
    const userData = await AuthStorage.getUser();
    const token = await AuthStorage.getToken();
    
    if (userData?.userId && token) {
      // Check internet connectivity before generating notification token
      const isConnected = await checkInternetConnectivity();
      if (isConnected) {
        // User is already logged in, generate and store notification token
        generateAndStoreNotificationToken(userData.userId).catch(error => {
          console.error('Error handling notification token on app start:', error);
        });
      } else {
        console.log('No internet connection available for notification token generation on app start');
      }
    }
  } catch (error) {
    console.error('Error checking login status for notification token:', error);
  }
};

// Export the connectivity check function for use in other parts of the app
export { checkInternetConnectivity };

// controllers/authController.js
import pool from "../config/database.js";
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import { UserDefinedMessageInstance } from "twilio/lib/rest/api/v2010/account/call/userDefinedMessage.js";
import { useId } from "react";

const register = async (req, res) => {
  const { mobileNumber, fullName } = req.body;
  console.log("register ",mobileNumber);
  //first checking if user is already exists or not
  try {
    const result = await pool.query(
      `SELECT * FROM users WHERE "mobile_number" = $1`,
      [mobileNumber]
    );
    console.log("response",result.rows);
    if (result.rows.length > 0) {
      res.json({ success: false, message: "Mobile number already registed" });
    } else {
      // Create user with default role 'sevak' and default usage_permission ['mobile']
      const result = await pool.query(
        `INSERT INTO "users" ("mobile_number", "full_name", "role", "usage_permission") VALUES ($1, $2, $3, $4) RETURNING *`,
        [mobileNumber, fullName, 'sevak', ['mobile']]
      );
      console.log("result",result.rows);
      console.log("inserted successfully");
      res.json({
        success: true,
        message: "Registration request sent to admin",
      });
    }
  } catch (error) {
    res.status(400).json({ success: false, message: error.message });
  }
};

// controllers/authController.js
const login = async (req, res) => {
  const { mobileNumber, password } = req.body;
  console.log("Login attempt:", mobileNumber, password);
  
  try {
    const result = await pool.query(
      `SELECT * FROM "SevakMaster" WHERE "mobileno" = $1 AND "password" = $2`,
      [mobileNumber, password]
    );
    if (result.rows.length > 0) {
      const sevak = result.rows[0];
      console.log("sevak",sevak);
      
      // Check usage permission (now an array)
      const canlogin = sevak.canlogin;
      if (canlogin !== 1) {
        return res.json({
          success: false,
          message: `Access denied. Please Contack Sevak Karyalay`,
        });
      }
      
      const token = jwt.sign(
        { userId: sevak.seid, role: sevak.usertype },
        process.env.JWT_SECRET
      );
      
      res.json({
        success: true,
        token: token,
        sevak:sevak,
      });
    } else {
      res.json({
        success: false,
        message: "Invalid Credential. Check your Mobile Number and Password",
      });
    }
  } catch (error) {
    console.error("Login error in backend:", error);
    res.status(500).json({ success: false, message: "Server error. Please try again." });
  }
};

const checkUser = async (req, res) => {
  const { mobileNumber } = req.body;
  
  try {
    const result = await pool.query(
      'SELECT * FROM "users" WHERE "mobile_number" = $1',
      [mobileNumber]
    );
    
    if (result.rows.length > 0) {
      res.json({ 
        exists: true
      });
    } else {
      res.json({ exists: false });
    }
  } catch (error) {
    console.error("Check user error:", error.message);
    res.status(400).json({ success: false, message: error.message });
  }
};

const checkMobileExists = async (req, res) => {
  const { mobileNumber } = req.body;
  console.log("Check mobile exists request:", mobileNumber);
  try {
    const result = await pool.query(
      'SELECT * FROM "SevakMaster" WHERE "mobileno" = $1',
      [mobileNumber]
    );
    if (result.rows.length > 0) {
      res.json({ exists: true,ispasswordSet:result.rows[0].password !== null, message: "Mobile number found" });
    } else {
      res.json({ exists: false,ispasswordSet:false, message: "Mobile number not found" });
    }
  } catch (error) {
    console.error("Check mobile error:", error.message);
    res.status(400).json({ success: false, message: error.message });
  }
};
export default { register, login, checkUser, checkMobileExists };


// components/forms/LoginForm.tsx
import React, { useState, useEffect, useCallback } from "react";
import {
  View,
  Text,
  Alert,
  KeyboardAvoidingView,
  Platform,
  Pressable,
  Keyboard,
  ScrollView,
  TextInput,
  Modal,
  ActivityIndicator,
  Animated,
} from "react-native";
import { router } from "expo-router";
import { Ionicons } from "@expo/vector-icons";
import CustomButton from "../ui/CustomButton";
import CustomInput from "../ui/CustomInput";
import { login, checkMobileExists } from "@/api/auth";
import { updateDevIP } from "@/constants/api";
import { getDefaultDevIP } from "@/app/index";
import { useSimCards } from "@/hooks/useSimCards";

interface SimCard {
  phoneNumber: string;
  carrierName: string;
  slotIndex: number;
}

type LoginStep = "mobile" | "password";

export default function LoginForm() {
  // Step management
  const [currentStep, setCurrentStep] = useState<LoginStep>("mobile");
  
  // Form fields
  const [mobileNumber, setMobileNumber] = useState("");
  const [password, setPassword] = useState("");
  
  // Loading states
  const [isLoading, setIsLoading] = useState(false);
  const [isCheckingMobile, setIsCheckingMobile] = useState(false);
  
  // UI states
  const [showPassword, setShowPassword] = useState(false);
  const [touched, setTouched] = useState({ mobile: false, password: false });
  
  // SIM related states
  const [availableSimCards, setAvailableSimCards] = useState<SimCard[]>([]);
  const [showSimPickerModal, setShowSimPickerModal] = useState(false);
  
  // Dev mode states
  const [devIP, setDevIP] = useState(getDefaultDevIP());
  const [showIPModal, setShowIPModal] = useState(false);
  
  // Animation
  const [fadeAnim] = useState(new Animated.Value(1));
  
  // Hook for SIM cards
  const { fetchSimCards, isLoading: isFetchingSim, isSupported } = useSimCards();

  // Auto-fetch mobile numbers on mount
  useEffect(() => {
    handleFetchMobileNumbers();
  }, []);

  // Animate step transition
  const animateStepChange = (callback: () => void) => {
    Animated.sequence([
      Animated.timing(fadeAnim, {
        toValue: 0,
        duration: 150,
        useNativeDriver: true,
      }),
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 150,
        useNativeDriver: true,
      }),
    ]).start();
    
    setTimeout(callback, 150);
  };

  // Fetch mobile numbers from SIM
  const handleFetchMobileNumbers = useCallback(async () => {
    Keyboard.dismiss();
    
    try {
      const simCards = await fetchSimCards();
      
      if (simCards.length === 0) {
        Alert.alert(
          "Not Supported",
          "Automatic mobile number fetch is not supported on this device. Please enter your mobile number manually.",
          [{ text: "OK" }]
        );
        return;
      }
      
      if (simCards.length === 1) {
        // Only one SIM, auto-fill
        setMobileNumber(simCards[0].phoneNumber);
        setAvailableSimCards(simCards);
      } else {
        // Multiple SIMs, show picker
        setAvailableSimCards(simCards);
        setShowSimPickerModal(true);
      }
    } catch (error) {
      Alert.alert(
        "Not Supported",
        "Automatic mobile number fetch is not supported on this device. Please enter your mobile number manually.",
        [{ text: "OK" }]
      );
    }
  }, [fetchSimCards]);

  // Handle SIM selection from picker
  const handleSelectSimCard = (simCard: SimCard) => {
    setMobileNumber(simCard.phoneNumber);
    setShowSimPickerModal(false);
  };

  // Handle Next button (check mobile exists)
  const handleNext = async () => {
    Keyboard.dismiss();
    setTouched((prev) => ({ ...prev, mobile: true }));

    if (!mobileNumber.trim()) {
      Alert.alert("Error", "Please enter your mobile number");
      return;
    }

    // Validate mobile number format (basic validation)
    const cleanedNumber = mobileNumber.replace(/[^0-9+]/g, "");
    if (cleanedNumber.length < 10) {
      Alert.alert("Error", "Please enter a valid mobile number");
      return;
    }

    try {
      setIsCheckingMobile(true);
      
      const response = await checkMobileExists(cleanedNumber);
      console.log("response in check mobile exists", response);
      if (response.exists) {
        // Mobile exists, show password input
        animateStepChange(() => {
          setCurrentStep("password");
        });
      } else {
        Alert.alert(
          "Not Found",
          `${cleanedNumber} is not registered. Please contact Sevak Karyalay.`
        );
      }
    } catch (error: any) {
      console.error("Check mobile error:", error);
      Alert.alert("Error", "Failed to verify mobile number. Please try again.");
    } finally {
      setIsCheckingMobile(false);
    }
  };

  // Handle back to mobile step
  const handleBackToMobile = () => {
    animateStepChange(() => {
      setCurrentStep("mobile");
      setPassword("");
      setTouched((prev) => ({ ...prev, password: false }));
    });
  };

  // Handle Login
  const handleLogin = async () => {
    Keyboard.dismiss();
    setTouched({ mobile: true, password: true });

    if (!password) {
      Alert.alert("Error", "Please enter your password");
      return;
    }

    const response = await login(mobileNumber, password);
    console.log("Login response:", response);
      if (response.success) {
        router.replace("/loginsuccess");
      } else {
        Alert.alert("Error", response.message);
      }
  };

  // Long press for dev mode
  const handleLongPressButton = () => {
    Keyboard.dismiss();
    Alert.alert(
      "ðŸ”§ Developer Mode",
      "Would you like to configure the backend IP address?",
      [
        { text: "Cancel", style: "cancel" },
        { text: "Configure", onPress: () => setShowIPModal(true) },
      ]
    );
  };

  // Handle background press
  const handleBackgroundPress = () => {
    Keyboard.dismiss();
  };

  // Render Mobile Input Step
  const renderMobileStep = () => (
    <View>
      {/* Mobile Input with Fetch Button */}
      <View className="mb-6">
        <CustomInput
          label="Mobile Number"
          placeholder="Enter mobile number"
          value={mobileNumber}
          onChangeText={setMobileNumber}
          keyboardType="phone-pad"
          leftIcon={
            <Ionicons name="call-outline" size={20} color="#6B7280" />
          }
          rightIcon={
            <Pressable
              onPress={handleFetchMobileNumbers}
              disabled={isFetchingSim}
              hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
              className="bg-blue-100 p-2 rounded-lg"
            >
              {isFetchingSim ? (
                <ActivityIndicator size="small" color="#3B82F6" />
              ) : (
                <Ionicons name="phone-portrait-outline" size={20} color="#3B82F6" />
              )}
            </Pressable>
          }
          error={
            !mobileNumber && touched.mobile ? "Mobile number is required" : ""
          }
          touched={touched.mobile}
          onBlur={() => setTouched((prev) => ({ ...prev, mobile: true }))}
        />
        
        {/* Hint text */}
        <Pressable onPress={handleFetchMobileNumbers} disabled={isFetchingSim}>
          <Text className="text-xs text-blue-500 mt-2 ml-1">
            <Ionicons name="information-circle-outline" size={12} /> Tap the phone icon to auto-fetch your number
          </Text>
        </Pressable>
      </View>

      {/* Next Button */}
      <Pressable
        onPress={handleNext}
        onLongPress={handleLongPressButton}
        delayLongPress={3000}
        disabled={isCheckingMobile}
      >
        {({ pressed }) => (
          <View
            pointerEvents="none"
            style={{ opacity: pressed ? 0.8 : 1 }}
          >
            <CustomButton
              title="Next"
              onPress={() => {}}
              loading={isCheckingMobile}
              IconRight={() => (
                <Ionicons name="arrow-forward" size={20} color="white" />
              )}
            />
          </View>
        )}
      </Pressable>
    </View>
  );

  // Render Password Step
  const renderPasswordStep = () => (
    <View>
      {/* Show selected mobile number */}
      <View className="bg-gray-100 rounded-xl p-4 mb-5 flex-row items-center">
        <View className="bg-blue-500 p-2 rounded-lg mr-3">
          <Ionicons name="call" size={20} color="white" />
        </View>
        <View className="flex-1">
          <Text className="text-xs text-gray-500">Logging in as</Text>
          <Text className="text-base font-JakartaBold text-gray-800">
            {mobileNumber}
          </Text>
        </View>
        <Pressable
          onPress={handleBackToMobile}
          hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
        >
          <Ionicons name="pencil" size={20} color="#6B7280" />
        </Pressable>
      </View>

      {/* Password Input */}
      <View className="mb-6">
        <CustomInput
          label="Password"
          placeholder="Enter password"
          value={password}
          onChangeText={setPassword}
          secureTextEntry={!showPassword}
          leftIcon={
            <Ionicons name="lock-closed-outline" size={20} color="#6B7280" />
          }
          rightIcon={
            <Pressable
              onPress={() => setShowPassword(!showPassword)}
              hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
            >
              <Ionicons
                name={showPassword ? "eye-outline" : "eye-off-outline"}
                size={20}
                color="#6B7280"
              />
            </Pressable>
          }
          error={!password && touched.password ? "Password is required" : ""}
          touched={touched.password}
          onBlur={() => setTouched((prev) => ({ ...prev, password: true }))}
        />
      </View>

      {/* Sign In Button */}
      <Pressable
        onPress={handleLogin}
        onLongPress={handleLongPressButton}
        delayLongPress={3000}
        disabled={isLoading}
      >
        {({ pressed }) => (
          <View
            pointerEvents="none"
            style={{ opacity: pressed ? 0.8 : 1 }}
          >
            <CustomButton
              title="Sign In"
              onPress={() => {}}
              loading={isLoading}
              IconRight={() => (
                <Ionicons name="arrow-forward" size={20} color="white" />
              )}
            />
          </View>
        )}
      </Pressable>

      {/* Back Button */}
      <Pressable
        onPress={handleBackToMobile}
        className="mt-4 flex-row items-center justify-center"
      >
        <Ionicons name="arrow-back" size={16} color="#6B7280" />
        <Text className="text-gray-500 ml-1">Use a different number</Text>
      </Pressable>
    </View>
  );

  return (
    <KeyboardAvoidingView
      behavior={Platform.OS === "ios" ? "padding" : "height"}
      className="flex-1 bg-white"
      keyboardVerticalOffset={Platform.OS === "ios" ? 0 : 20}
    >
      <ScrollView
        contentContainerStyle={{ flexGrow: 1 }}
        showsVerticalScrollIndicator={false}
        keyboardShouldPersistTaps="handled"
        bounces={false}
      >
        <Pressable
          onPress={handleBackgroundPress}
          className="flex-1 bg-white justify-start"
        >
          <View className="flex-row flex-1">
            <View className="w-[10%]" />

            <View className="w-[80%] pt-8">
              {/* Header Section */}
              <View className="items-center mb-8">
                <View className="w-20 h-20 rounded-2xl bg-blue-500 items-center justify-center mb-5">
                  <Ionicons name="shield-checkmark" size={40} color="white" />
                </View>
                <Text className="text-2xl font-JakartaBold text-gray-800 mb-2">
                  {currentStep === "mobile" ? "Welcome" : "Enter Password"}
                </Text>
                <Text className="text-sm text-gray-500 text-center">
                  {currentStep === "mobile"
                    ? "Enter your mobile number to continue"
                    : "Enter your password to sign in"}
                </Text>
              </View>

              {/* Step Indicator */}
              <View className="flex-row items-center justify-center mb-6">
                <View
                  className={`w-3 h-3 rounded-full ${
                    currentStep === "mobile" ? "bg-blue-500" : "bg-green-500"
                  }`}
                />
                <View
                  className={`w-16 h-1 mx-2 ${
                    currentStep === "password" ? "bg-green-500" : "bg-gray-200"
                  }`}
                />
                <View
                  className={`w-3 h-3 rounded-full ${
                    currentStep === "password" ? "bg-blue-500" : "bg-gray-200"
                  }`}
                />
              </View>

              {/* Form Section with Animation */}
              <Animated.View style={{ opacity: fadeAnim }}>
                {currentStep === "mobile"
                  ? renderMobileStep()
                  : renderPasswordStep()}
              </Animated.View>
            </View>

            <View className="w-[10%]" />
          </View>
        </Pressable>
      </ScrollView>

      {/* SIM Card Picker Modal */}
      <Modal
        visible={showSimPickerModal}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setShowSimPickerModal(false)}
      >
        <Pressable
          onPress={() => setShowSimPickerModal(false)}
          className="flex-1 bg-black/50 justify-end"
        >
          <Pressable
            onPress={() => {}}
            className="bg-white rounded-t-3xl pt-6 pb-8 px-5"
          >
            {/* Handle Bar */}
            <View className="w-10 h-1 bg-gray-300 rounded-full self-center mb-4" />
            
            <Text className="text-xl font-JakartaBold text-gray-800 mb-2">
              Choose Your Number
            </Text>
            <Text className="text-sm text-gray-500 mb-5">
              Multiple SIM cards detected. Please select which number to use.
            </Text>

            {/* SIM Cards List */}
            {availableSimCards.map((sim, index) => (
              <Pressable
                key={index}
                onPress={() => handleSelectSimCard(sim)}
                className="bg-gray-50 border border-gray-200 rounded-xl p-4 mb-3 flex-row items-center active:bg-gray-100"
              >
                <View className="bg-blue-500 p-3 rounded-xl mr-4">
                  <Ionicons name="phone-portrait" size={24} color="white" />
                </View>
                <View className="flex-1">
                  <Text className="text-sm text-gray-500">
                    SIM {sim.slotIndex + 1} â€¢ {sim.carrierName}
                  </Text>
                  <Text className="text-lg font-JakartaBold text-gray-800">
                    {sim.phoneNumber}
                  </Text>
                </View>
                <Ionicons name="chevron-forward" size={24} color="#6B7280" />
              </Pressable>
            ))}

            {/* Manual Entry Option */}
            <Pressable
              onPress={() => {
                setShowSimPickerModal(false);
                setMobileNumber("");
              }}
              className="mt-2 py-3 flex-row items-center justify-center"
            >
              <Ionicons name="keypad-outline" size={18} color="#6B7280" />
              <Text className="text-gray-500 ml-2">Enter number manually</Text>
            </Pressable>
          </Pressable>
        </Pressable>
      </Modal>

      {/* IP Modal - Developer Mode */}
      <Modal
        visible={showIPModal}
        transparent={true}
        animationType="fade"
        onRequestClose={() => {
          Keyboard.dismiss();
          setShowIPModal(false);
        }}
      >
        <Pressable
          onPress={() => {
            Keyboard.dismiss();
            setShowIPModal(false);
          }}
          className="flex-1 bg-black/50 items-center justify-center"
        >
          <Pressable
            onPress={() => {}}
            className="bg-white p-5 rounded-2xl w-[80%]"
          >
            <Text className="text-lg font-JakartaBold mb-4">
              Set Backend IP Address
            </Text>
            <TextInput
              placeholder="e.g., 192.168.1.100:3000"
              value={devIP.replace(/^https?:\/\//, "")}
              onChangeText={(text) => setDevIP(text)}
              keyboardType="url"
              className="border border-gray-300 rounded-lg px-4 py-3 mb-5"
            />
            <View className="flex-row gap-3">
              <View className="flex-1">
                <CustomButton
                  title="Cancel"
                  onPress={() => {
                    Keyboard.dismiss();
                    setShowIPModal(false);
                  }}
                  bgVariant="secondary"
                />
              </View>
              <View className="flex-1">
                <CustomButton
                  title="Save"
                  onPress={() => {
                    Keyboard.dismiss();
                    if (!devIP.trim()) {
                      Alert.alert("Error", "IP address cannot be empty.");
                      return;
                    }
                    let formattedUrl = devIP.trim();
                    if (
                      !formattedUrl.startsWith("http://") &&
                      !formattedUrl.startsWith("https://")
                    ) {
                      formattedUrl = "http://" + formattedUrl;
                    }
                    updateDevIP(formattedUrl);
                    setDevIP(formattedUrl);
                    Alert.alert(
                      "Success",
                      `Backend IP updated to:\n${formattedUrl}`
                    );
                    setShowIPModal(false);
                  }}
                  bgVariant="success"
                />
              </View>
            </View>
          </Pressable>
        </Pressable>
      </Modal>
    </KeyboardAvoidingView>
  );
}

// utils/authStorage.ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import { User } from '@/types/type';

export const AuthStorage = {
  // Store sevak data
  async storeSevakData(sevak: any) {
    try {
      await AsyncStorage.setItem('sevakData', JSON.stringify(sevak));
      console.log('Sevak data stored successfully');
    } catch (error) {
      console.error('Error storing sevak data:', error);
    }
  },

  // Get sevak data
  async getSevakData(): Promise<any | null> {
    try {
      const sevakDataString = await AsyncStorage.getItem('sevakData');
      console.log('Sevak data retrieved successfully');
      console.log('Sevak data:', sevakDataString);
      return sevakDataString ? JSON.parse(sevakDataString) : null;
    } catch (error) {
      console.error('Error getting sevak data:', error);
      throw error;
    }
  },

  // Store user token
  async storeToken(token: string) {
    try {
      await AsyncStorage.setItem('userToken', token);
      console.log('Token stored successfully');
    } catch (error) {
      console.error('Error storing token:', error);
    }
  },

  // Get user token
  async getToken(): Promise<string | null> {
    try {
      const token = await AsyncStorage.getItem('userToken');
      console.log('Token retrieved successfully');
      console.log('Token:', token);
      return token;
    } catch (error) {
      console.error('Error getting token:', error);
      throw error;
    }
  },

  // Store user data
  async storeUser(userData: any) {
    try {
      await AsyncStorage.setItem('userData', JSON.stringify(userData));
      console.log('User data stored successfully');
      console.log('User data:', userData);
    } catch (error) {
      console.error('Error storing user data:', error);
      throw error;
    }
  },

  // Get user data
  async getUser(): Promise<User | null> {
    try {
      const userDataString = await AsyncStorage.getItem('userData');
      // console.log('Stored user data string:', userDataString);
      
      if (!userDataString) {
        console.log('No user data found in storage');
        throw new Error('No user data found in storage');
      }
      
      const userData = JSON.parse(userDataString);
      console.log("userData", userData);
      return userData as User;
    } catch (error) {
      console.error('Error retrieving user data:', error);
      throw error;
    }
  },

  // Store user role
  async storeUserRole(role: string) {
    try {
      await AsyncStorage.setItem('userRole', role);
    console.log('User role stored successfully');
    console.log('User role:', role);
    } catch (error) {
      console.error('Error storing user role:', error);
      throw error;
    }
  },

  // Get user role
  async getUserRole(): Promise<string | null> {
    try {
      const userRole = await AsyncStorage.getItem('userRole');
    console.log('User role retrieved successfully');
    console.log('User role:', userRole);
    return userRole as string | null;
    } catch (error) {
      console.error('Error getting user role:', error);
      throw error;
    }
  },

  // Clear all auth data
  async clear() {
    try {
      await AsyncStorage.removeItem('userToken');
      await AsyncStorage.removeItem('userData');
      await AsyncStorage.removeItem('userRole');
      console.log('All auth data cleared successfully');
    } catch (error) {
      console.error('Error clearing auth data:', error);
      throw error;
    }
  }
};

here is my all 4 files 
now i want proper flow for all cases

1) check in authstorage if token exist then no need of authentication
2) if token not exists
3) show that mobile number fetch screen 
4) featch mobile number
on press next make api call to backend for checking user's mobile number
if mobile number not exits then show message like "Mobile Number not exists contact Sevak karyalay"
if mobile number exists then 
check password is set or not 
if set then show password input field and user will enter the password if password is correct then redirect to loginsuccess route else show alert like wrong password -> check mobile number or enter correct password
if not set then show set password field and after presses set password show alert with text as setting password as {entered password} and redirect to logic success page 